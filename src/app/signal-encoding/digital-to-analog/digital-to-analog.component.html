<div id="input-data">
	<app-binary-data (binaryDataChange)="setSignal($event)"></app-binary-data>
</div>

<div id="techniques">
	<button (click)="technique = 'ask'"> Amplitude Shift Keying (ASK) </button>
	<button (click)="technique = 'bfsk'"> Binary Frequency Shift Keying (BFSK) </button>
	<button (click)="technique = 'bpsk'"> Binary Phase Shift Keying (BPSK) </button>
</div>

<h1>
	@switch (technique) {
		@case ('ask') {
			Amplitude Shift Keying (ASK)
		}
		@case ('bfsk') {
			Binary Frequency Shift Keying (BFSK)
		}
		@case ('bpsk') {
			Binary Phase Shift Keying (BPSK) 
		}
	}
</h1>

@if (data().length) {
	@switch (technique) {
		@case ('ask') {
			<p>
				Threshold: {{ threshold }}
			</p>
			<input type="range" min="0" max="5" step="0.01" value="2.5" (input)="setThreshold($event)">
			<p>
				If the amplitude of the signal is greater than the threshold, the interpreted bit is 1, otherwise it is 0.
			</p>

			<div class="signal-container">
				<div class="cell-container">
					<div class="data-cell">
						<div class="signal-container">
							Sender
						</div>
					</div>
					@for (item of data(); track $index) {
					<div class="data-cell">
						<div class="signal-container">
							<div class="top-left-dashed"></div>
							<div class="bottom-left-dashed"></div>
			
							<div class="left-analog-signal"></div>
	
							<svg width="140px" height="140px">
								<path stroke="blue" stroke-width="2"
								[attr.d]="askSender().signals[$index].signal"></path>
							</svg>
						</div>
					</div>
					}
				</div>
	
				<div class="cell-container">
					<div class="data-cell">
						<div class="signal-container">
							Receiver
						</div>
					</div>
					@for (item of data(); track $index) {
					<div class="data-cell">
						<div class="signal-container">
							<div class="top-left-dashed"></div>
							<div class="bottom-left-dashed"></div>
			
							<div class="left-analog-signal"></div>
	
							<svg width="140px" height="140px">
								<path [attr.d]="askReceiver().signals[$index].signal" stroke="blue" stroke-width="2"></path>
							</svg>
						</div>
	
						<div class="amplitudes">
							<input type="range" min="0" max="5" step="0.01"
							#signal
							[value]="askReceiver().signals[$index].amplitude.toString()"
							(input)="setAmplitude(signal, $index)">
							<p>
								Amplitude: {{ askReceiver().signals[$index].amplitude }}
							</p>
						</div>
	
						<div class="bit">
							{{ askReceiver().receiverData[$index] }}
						</div>
					</div>
					}
				</div>
			</div>

			<p>
				Interpreted data by receiver:
				@for (item of askReceiver().receiverData; track $index) {
					<span [style.color]="item === this.data()[$index] ? 'inherit' : 'red'"> {{ item }} </span>
				}
			</p>

			<p>
				In ASK, the two binary values are represented by two different amplitudes of the carrier
				frequency. Commonly, one of the amplitudes is zero; that is, one binary digit is represented by the
				presence, at constant amplitude, of the carrier, the other by the absence of the carrier. The resulting transmitted signal for one bit time is
			</p>

			<div id="ask-function">
				<table>
					<tr>
						<td [innerText]="'S(t) = {'">
							
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							(A.cos(2.π.f<sub>c</sub>.t) )
						</td>
						<td>
							;
						</td>
						<td>
							binary 1
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							0
						</td>
						<td>
							;
						</td>
						<td>
							binary 0
						</td>
						
					</tr>
					<tr>
						<td [innerText]="'}'">
							
						</td>
					</tr>
				</table>
			</div>

			<p>
				where
			</p>
			<ul>
				<li>A: Amplitude of carrier signal</li>
				<li>f<sub>c</sub>: carrier frequency</li>
				<li> Carrier signal = A.cos(2.π.f.<sub>c</sub>.t) </li>
			</ul>
			<p>
				ASK is susceptible to sudden gain changes and is a rather inefficient modulation technique. On voicegrade lines, it is typically used only up to 1200 bps.
			</p>
			<p>
				The ASK technique is used to transmit digital data over optical fiber, where one signal element is
				represented by a light pulse while the other signal element is represented by the absence of light.
			</p>
			
		}
		@case ('bfsk') {
			<p>
				Offset Frequency: {{ bfskOffsetFrequency() }}
			</p>
			<input #bfskOffset type="range" min="0" max="10000" step="100" [value]="bfskOffsetFrequency().toString()" (input)="setBfskOffsetFrequency(bfskOffset)">

			<div class="signal-container">
				<div class="cell-container">
					<div class="data-cell">
						<div class="signal-container">
							Binary Frequency Shift Keying (BFSK)
						</div>
					</div>
					@for (item of data(); track $index) {
					<div class="data-cell">
						
			
						<div class="signal-container">
							<div class="top-left-dashed"></div>
							<div class="bottom-left-dashed"></div>
			
							<div class="left-analog-signal"></div>
	
							<svg width="140px" height="140px">
								<path stroke="blue" stroke-width="2"
								[attr.d]="bfskSignals().signals[$index].signal"></path>
							</svg>
						</div>
	
						<div class="amplitudes">
							<input type="range" min="0" max="10000" step="100"
							#signal
							[value]="bfskSignals().signals[$index].frequency.toString()"
							(input)="setFrequency(signal, $index)">
							<p>
								f: {{ bfskSignals().signals[$index].frequency }}
							</p>
						</div>
	
						<div class="bit">
							{{ bfskSignals().receiverData[$index] }}
						</div>
	
					</div>
					}
				</div>
			</div>

			<svg viewBox="0 0 200 100" width="50%">
				<text x="170" y="99" font-size="4" fill="white">Frequency (Hz)</text>
				// create x-axis that have arrow
				<defs>
					<marker 
					  id='head' 
					  orient="auto" 
					  markerWidth='3' 
					  markerHeight='4' 
					  refX='0.1' 
					  refY='2'
					>
					  <path d='M0,0 V4 L2,2 Z' fill="white" />
					</marker>
				  </defs>
				
				  <path
					id='x-axis'
					marker-end='url(#head)'
					stroke-width='1'
					fill='none' stroke='white'
					d='M0,90, 190 90,120'
				  />

				  <path
					id='y-axis'
					marker-end='url(#head)'
					stroke-width='1'
					fill='none' stroke='white'
					d='M3,90, 3 10,120'
				  />

				  <path
					stroke-width='1'
					fill='none' stroke='white'
					d='M150,95, 150 90,120'
				  />

				  <path
					stroke-width='1'
					fill='none' stroke='white'
					d='M3,95, 3 90,120'
				  />

				  <path
					stroke-width='1'
					fill='none' stroke='white'
					[attr.d]='"M" + bfskOfssetNormalized() + ", 95," + bfskOfssetNormalized() + " 90, 120"'
				  />

				  <text [attr.x]="bfskOfssetNormalized() - 10" y="99" font-size="5" fill="white">
					offset: {{ bfskOffsetFrequency() }}
				  </text>

				  <text x="148" y="99" font-size="5" fill="white">10.000</text>
				  <text x="2" y="99" font-size="5" fill="white">0</text>
			</svg>

			<p>
				The most common form of FSK is binary FSK (BFSK), in which the two binary values are represented
				by two different frequencies near the carrier frequency (shown in Figure below) as
			</p>

			<div id="ask-function">
				<table>
					<tr>
						<td [innerText]="'S(t) = {'">
							
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							(A.cos(2.π.f<sub>1</sub>.t) )
						</td>
						<td>
							;
						</td>
						<td>
							binary 1
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							(A.cos(2.π.f<sub>2</sub>.t) )
						</td>
						<td>
							;
						</td>
						<td>
							binary 0
						</td>
						
					</tr>
					<tr>
						<td [innerText]="'}'">
							
						</td>
					</tr>
				</table>
			</div>

			<p>
				where f<sub>1</sub>, f<sub>2</sub> offset from carrier frequency (fc) by equal but opposite amount
			</p>
			<p>
				BFSK is less susceptible to error than ASK. On voice-grade lines, it is typically used up to 1200
				bps. It is also commonly used for high-frequency (3 to 30 MHz) radio transmission. It can also be used
				at even higher frequencies on local area networks that use coaxial cable
			</p>
		}
		@case ('bpsk') {
			<div class="signal-container">
				<div class="cell-container">
					<div class="data-cell">
						<div class="signal-container">
							Binary Phase Shift Keying (BPSK)
						</div>
					</div>
					@for (item of data(); track $index) {
					<div class="data-cell">
						<div class="bit">
							{{ data()[$index] }}
						</div>
			
						<div class="signal-container">
							<div class="top-left-dashed"></div>
							<div class="bottom-left-dashed"></div>
			
							<div class="left-analog-signal"></div>
			
							<svg width="140px" height="140px">
								<path [attr.d]="bpsk()[$index]" stroke="blue" stroke-width="2"></path>
							</svg>
						</div>
					</div>
					}
				</div>
			</div>

			<p>
				In PSK, the phase of the carrier signal is shifted to represent data. The simplest scheme uses two
				phases to represent the two binary digits (Figure below) and is known as binary phase shift keying.
				The resulting transmitted signal for one bit time is
			</p>

			<div id="ask-function">
				<table>
					<tr>
						<td [innerText]="'S(t) = {'">
							
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							A.cos(2.π.f<sub>c</sub>.t + π)
						</td>
						<td>
							;
						</td>
						<td>
							binary 1
						</td>
					</tr>
					<tr>
						<td></td>
						<td>
							A.cos(2.π.f<sub>c</sub>.t π) = -A.cos(2.π.f<sub>c</sub>.t π)
						</td>
						<td>
							;
						</td>
						<td>
							binary 0
						</td>
						
					</tr>
					<tr>
						<td [innerText]="'}'">
							
						</td>
					</tr>
				</table>
			</div>

			<p>
				Because a phase shift of 180<sup>o</sup> (π) is equivelent to flipping the sine wave or multiplying it by -1 Acos(2.π.f<sub>c</sub>.t+ π) = -Acos(2.π.f<sub>c</sub>.t) can be used instead.
			</p>
		}
	}
}
